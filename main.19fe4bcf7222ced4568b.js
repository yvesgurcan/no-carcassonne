(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["main"],{

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/index.scss":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/index.scss ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \"body {\\n  margin: 0;\\n  background: grey;\\n}\\n\\n#topbar {\\n  position: fixed;\\n  width: 100%;\\n  height: 60px;\\n  box-sizing: border-box;\\n  display: flex;\\n  justify-content: space-evenly;\\n  align-items: center;\\n  background: rgba(60, 60, 60, 0.7);\\n  border-bottom: 1px rgba(0, 0, 0, 0.7) solid;\\n  color: white;\\n  padding: 10px;\\n  z-index: 1;\\n}\\n\\n#world {\\n  padding-top: 240px;\\n  padding-left: 240px;\\n  min-width: 100vw;\\n  min-height: 100vh;\\n}\\n\\n#tile-to-place {\\n  position: absolute;\\n  pointer-events: none;\\n}\\n\\n#stack {\\n  position: fixed;\\n  top: calc(60px + 20px);\\n  right: 20px;\\n  background: rgba(30, 30, 30, 0.7);\\n  border: 1px rgba(0, 0, 0, 0.7) solid;\\n  width: 75px;\\n  height: 75px;\\n  color: white;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  cursor: pointer;\\n}\\n#stack div {\\n  text-align: center;\\n}\\n\\n#rotate {\\n  position: fixed;\\n  top: calc(60px + 20px);\\n  right: 20px;\\n  background: rgba(30, 30, 30, 0.7);\\n  border: 1px rgba(0, 0, 0, 0.7) solid;\\n  width: 75px;\\n  height: 75px;\\n  color: white;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  text-align: center;\\n  cursor: pointer;\\n}\\n\\n#place-meeple {\\n  position: fixed;\\n  top: calc(60px + 20px);\\n  right: 20px;\\n  background: rgba(30, 30, 30, 0.7);\\n  border: 1px rgba(0, 0, 0, 0.7) solid;\\n  width: 75px;\\n  height: 75px;\\n  color: white;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  text-align: center;\\n  cursor: pointer;\\n}\\n\\n#end-turn {\\n  position: fixed;\\n  top: calc(60px + 20px + 75px + 20px);\\n  right: 20px;\\n  background: rgba(30, 30, 30, 0.7);\\n  border: 1px rgba(0, 0, 0, 0.7) solid;\\n  width: 75px;\\n  height: 75px;\\n  color: white;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  text-align: center;\\n  cursor: pointer;\\n}\", \"\"]);\n// Exports\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./src/index.scss?./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/webpack/hot sync ^\\.\\/log$":
/*!*************************************************!*\
  !*** (webpack)/hot sync nonrecursive ^\.\/log$ ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var map = {\n\t\"./log\": \"./node_modules/webpack/hot/log.js\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./node_modules/webpack/hot sync ^\\\\.\\\\/log$\";\n\n//# sourceURL=webpack:///(webpack)/hot_sync_nonrecursive_^\\.\\/log$?");

/***/ }),

/***/ "./src/engine/RNG.js":
/*!***************************!*\
  !*** ./src/engine/RNG.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return RNG; });\n/* harmony import */ var alea__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! alea */ \"./node_modules/alea/alea.js\");\n/* harmony import */ var alea__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(alea__WEBPACK_IMPORTED_MODULE_0__);\n\nlet instance = null;\n/**\n * @property {*} [seed] A primitive used as a base to generate random numbers.\n */\n\nclass RNG {\n  /**\n   *\n   * @param {*} [seed] A primitive used as a base to generate random numbers.\n   * @returns {instanceof RNG} Singleton.\n   */\n  constructor(seed) {\n    if (!instance) {\n      this.init(seed);\n      instance = this;\n      return this;\n    } else {\n      return instance;\n    }\n  }\n  /**\n   * Initialize the random number generator with a seed.\n   * @param {*} [seed] A primitive used as a base to generate random numbers. The same seed will return the same sequence of numbers. If no seed is provided, a random number will be used as a base.\n   * @returns {instanceof RNG} Singleton.\n   */\n\n\n  init(seed) {\n    if (!this.rng) {\n      this.seed = seed === undefined ? this.newSeed : seed;\n      this.rng = new alea__WEBPACK_IMPORTED_MODULE_0___default.a(this.seed);\n      return this;\n    } else {\n      throw new Error('RNG already initialized.');\n    }\n  }\n  /**\n   * Initialize the random number generator without a seed.\n   * @returns {instanceof RNG} Singleton.\n   */\n\n\n  initUnseeded() {\n    if (!this.rng) {\n      this.rng = new alea__WEBPACK_IMPORTED_MODULE_0___default.a();\n      return this;\n    } else {\n      throw new Error('RNG already initialized.');\n    }\n  }\n  /**\n   * @returns {Number} A randomly generated seed.\n   */\n\n\n  get newSeed() {\n    return Number(String(Math.random()).replace('.', ''));\n  }\n  /**\n   * @returns {Number} The next new random number.\n   */\n\n\n  get next() {\n    return this.rng();\n  }\n  /**\n   *\n   * @param {Number} min The lower boundary of the range.\n   * @param {Number} max The upper boundary of the range.\n   * @returns {Number} A number greater than or equal to min and less than or equal to max.\n   */\n\n\n  range(min = 0, max = 100) {\n    if (min > max) {\n      throw new Error(`Min \"${min}\" greater than max \"${max}\".`);\n    }\n\n    return Math.floor(this.rng() * (max - min)) + min;\n  }\n\n}\n\n//# sourceURL=webpack:///./src/engine/RNG.js?");

/***/ }),

/***/ "./src/engine/gameLogic.js":
/*!*********************************!*\
  !*** ./src/engine/gameLogic.js ***!
  \*********************************/
/*! exports provided: initRNG, pickRandomTile, generateTiles, pickStartTile, removeTileFromStack, rotateTile, canConnectNodes, getInternalNodesWithTileId */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"initRNG\", function() { return initRNG; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pickRandomTile\", function() { return pickRandomTile; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"generateTiles\", function() { return generateTiles; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pickStartTile\", function() { return pickStartTile; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeTileFromStack\", function() { return removeTileFromStack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateTile\", function() { return rotateTile; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"canConnectNodes\", function() { return canConnectNodes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getInternalNodesWithTileId\", function() { return getInternalNodesWithTileId; });\n/* harmony import */ var _tileTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tileTypes */ \"./src/engine/tileTypes.js\");\n/* harmony import */ var _RNG__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RNG */ \"./src/engine/RNG.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util */ \"./src/util.js\");\n\n\n\nlet rng = undefined;\nfunction initRNG(seed) {\n  rng = new _RNG__WEBPACK_IMPORTED_MODULE_1__[\"default\"](seed);\n  return rng.seed;\n}\n/**\n *\n * @param {Map} stack A list of tiles to pick from.\n * @returns {Object} The selected tile and the index of that tile in the stack.\n */\n\nfunction pickRandomTile(stack = _tileTypes__WEBPACK_IMPORTED_MODULE_0__[\"TILE_TYPE_NUMBERED_MAP\"]) {\n  const index = rng.range(0, stack.size);\n  return {\n    tile: stack.get(index),\n    index\n  };\n}\n/**\n *\n * @param {Number} numberToGenerate The number of tiles the function should return.\n * @returns {Map} A map of tiles.\n */\n\nfunction generateTiles(numberToGenerate) {\n  let newTiles = new Map();\n\n  for (let i = 0; i < numberToGenerate; i++) {\n    const {\n      tile\n    } = pickRandomTile();\n    newTiles.set(i, new Map(tile));\n  }\n\n  return newTiles;\n}\n/**\n * @returns {Map} First tile\n */\n\nfunction pickStartTile(extensions = []) {\n  if (extensions.includes('Random start tile')) {\n    return pickRandomTile().tile;\n  }\n\n  if (extensions.includes('River')) {\n    return _tileTypes__WEBPACK_IMPORTED_MODULE_0__[\"TILE_TYPE_NAMED_MAP\"].get('Spring');\n  }\n\n  return _tileTypes__WEBPACK_IMPORTED_MODULE_0__[\"START_TILE\"];\n}\n/**\n *\n * @param {Map} stack A list of tiles to remove the tile from.\n * @returns {Object} The removed tile and the updated list of tiles.\n */\n\nfunction removeTileFromStack(stack) {\n  if (stack.size === 0) {\n    return {\n      tile: undefined,\n      updatedStack: stack\n    };\n  }\n\n  const lastTile = stack.size - 1;\n  const tile = stack.get(lastTile);\n  const updatedStack = new Map(stack);\n  updatedStack.delete(lastTile);\n  return {\n    tile,\n    updatedStack\n  };\n}\nfunction rotateTile(tile) {\n  const rotatedTile = new Map(tile);\n  rotatedTile.set(0, tile.get(8));\n  rotatedTile.set(1, tile.get(5));\n  rotatedTile.set(2, tile.get(3));\n  rotatedTile.set(3, tile.get(10));\n  rotatedTile.set(4, tile.get(0));\n  rotatedTile.set(5, tile.get(11));\n  rotatedTile.set(7, tile.get(1));\n  rotatedTile.set(8, tile.get(12));\n  rotatedTile.set(9, tile.get(2));\n  rotatedTile.set(10, tile.get(9));\n  rotatedTile.set(11, tile.get(7));\n  rotatedTile.set(12, tile.get(4)); // TODO: Rotate internal nodeRelations\n\n  return rotatedTile;\n}\n/**\n *\n * @param {Array} nodesA A list of nodes.\n * @param {Array} nodesB A list of nodes.\n * @returns {Boolean}\n */\n\nfunction canConnectNodes(nodesA, nodesB) {\n  if (nodesA.length !== 3 || nodesB.length !== 3) {\n    return false;\n  }\n\n  for (let i = 0; i < 3; i++) {\n    const featureA = nodesA[i].feature;\n    const featureB = nodesB[i].feature;\n\n    if (featureA !== featureB) {\n      return false;\n    }\n  }\n\n  return true;\n}\nfunction getInternalNodesWithTileId(tileId, tile) {\n  const updatedNodeRelations = new Map();\n  tile.get('nodeRelations').forEach((values, key) => {\n    if (Object(_util__WEBPACK_IMPORTED_MODULE_2__[\"isNumber\"])(key)) {\n      const updatedValues = values.map(v => `${tileId}/${v}`);\n      updatedNodeRelations.set(`${tileId}/${key}`, updatedValues);\n    }\n  });\n  return updatedNodeRelations;\n}\n\n//# sourceURL=webpack:///./src/engine/gameLogic.js?");

/***/ }),

/***/ "./src/engine/nodeTypes.js":
/*!*********************************!*\
  !*** ./src/engine/nodeTypes.js ***!
  \*********************************/
/*! exports provided: GRASS, BLANK, CITY, ROAD, CROSSROAD, MONASTERY, RIVER, GARDEN, EMPTY_NODE */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GRASS\", function() { return GRASS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BLANK\", function() { return BLANK; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CITY\", function() { return CITY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ROAD\", function() { return ROAD; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CROSSROAD\", function() { return CROSSROAD; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MONASTERY\", function() { return MONASTERY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RIVER\", function() { return RIVER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GARDEN\", function() { return GARDEN; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EMPTY_NODE\", function() { return EMPTY_NODE; });\nconst GRASS = 'G';\nconst BLANK = 'B';\nconst CITY = 'C';\nconst ROAD = 'R';\nconst CROSSROAD = 'X';\nconst MONASTERY = 'M';\nconst RIVER = 'S'; // 'S' for 'Stream'\n\nconst GARDEN = 'G';\nconst EMPTY_NODE = {\n  feature: GRASS,\n  owners: []\n};\n\n//# sourceURL=webpack:///./src/engine/nodeTypes.js?");

/***/ }),

/***/ "./src/engine/tileTypes.js":
/*!*********************************!*\
  !*** ./src/engine/tileTypes.js ***!
  \*********************************/
/*! exports provided: START_TILE, TILE_TYPE_NAMED_MAP, TILE_TYPE_NUMBERED_MAP */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"START_TILE\", function() { return START_TILE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TILE_TYPE_NAMED_MAP\", function() { return TILE_TYPE_NAMED_MAP; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TILE_TYPE_NUMBERED_MAP\", function() { return TILE_TYPE_NUMBERED_MAP; });\n/* harmony import */ var _nodeTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nodeTypes */ \"./src/engine/nodeTypes.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ \"./src/util.js\");\n\n\nconst NEIGHBOR_NODES_MAP = new Map([[0, [1, 3]], [1, [0, 2, 6]], [2, [1, 4]], [3, [0, 5]], [4, [2, 7]], [5, [3, 6, 8]], [6, [1, 5, 7, 11]], [7, [4, 6, 9]], [8, [5, 10]], [9, [7, 12]], [10, [8, 11]], [11, [6, 10, 12]], [12, [9, 11]]]);\n/**\n * @returns {Map} A tile where all nodes are populated with the default feature.\n */\n\nfunction generateEmptyTileTemplate() {\n  let tile = new Map();\n  const connections = new Array(13).fill({ ..._nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"EMPTY_NODE\"]\n  });\n  tile.set('name', 'Empty tile');\n  connections.forEach((connection, index) => {\n    tile.set(index, connection);\n  });\n  return tile;\n}\n\nconst EMPTY_TILE = generateEmptyTileTemplate();\n\nfunction generateTileNodeRelation(nodeIndex, tile) {\n  const nodeRelations = [];\n  const node = tile.get(nodeIndex);\n  const neighborNodeIndexes = NEIGHBOR_NODES_MAP.get(nodeIndex);\n  neighborNodeIndexes.forEach(neighborNodeIndex => {\n    const neighborNode = tile.get(neighborNodeIndex);\n\n    if (node.feature === neighborNode.feature) {\n      nodeRelations.push(neighborNodeIndex);\n    }\n  });\n  return nodeRelations;\n}\n/**\n *\n * @param {Array} tileData A list of nodes with specific features to generate the tile.\n * @returns {Map} A list of all the nodes that make the tile, including nodes using the default feature.\n */\n\n\nfunction generateTileTemplate(tileData) {\n  const tile = new Map(EMPTY_TILE);\n  tileData.forEach(([key, value]) => {\n    const connection = tile.get(key); // Only numbered properties are nodes\n\n    if (Object(_util__WEBPACK_IMPORTED_MODULE_1__[\"isNumber\"])(key)) {\n      // Keep other properties on the node\n      tile.set(key, { ...connection,\n        feature: value\n      });\n    } else {\n      tile.set(key, value);\n    }\n  });\n  const nodeRelations = new Map();\n  tile.forEach((value, key) => {\n    // Only numbered properties are nodes\n    if (Object(_util__WEBPACK_IMPORTED_MODULE_1__[\"isNumber\"])(key)) {\n      // Keep other properties on the node\n      nodeRelations.set(key, generateTileNodeRelation(key, tile));\n    }\n  });\n  tile.set('nodeRelations', nodeRelations);\n  return tile;\n}\n\nfunction generateTileTemplatesFromModifierMaps() {\n  let tiles = [];\n\n  for (const modifierMap in TILE_TYPE_MODIFIER_MAPS) {\n    const tile = generateTileTemplate(TILE_TYPE_MODIFIER_MAPS[modifierMap]);\n    tile.set('name', modifierMap);\n    tiles.push(tile);\n  }\n\n  return tiles;\n}\n\nconst TILE_TYPE_MODIFIER_MAPS = {\n  Spring: [[1, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"RIVER\"]], [6, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"RIVER\"]]],\n  Lake: [[1, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"RIVER\"]], [6, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"RIVER\"]]],\n  'Straight river': [[1, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"RIVER\"]], [6, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"RIVER\"]], [11, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"RIVER\"]]],\n  'River turn': [[1, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"RIVER\"]], [6, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"RIVER\"]], [7, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"RIVER\"]]],\n  'River with bridge': [[1, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"RIVER\"]], [11, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"RIVER\"]], [5, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"ROAD\"]], [6, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"ROAD\"]], [7, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"ROAD\"]]],\n  'River with city': [[1, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"RIVER\"]], [6, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"RIVER\"]], [11, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"RIVER\"]], [4, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [7, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [9, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]]],\n  'River with bridge and city': [[1, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"RIVER\"]], [11, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"RIVER\"]], [5, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"ROAD\"]], [6, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"ROAD\"]], [4, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [7, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [9, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]]],\n  'Straight road': [[1, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"ROAD\"]], [6, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"ROAD\"]], [11, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"ROAD\"]]],\n  'Road turn': [[1, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"ROAD\"]], [6, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"ROAD\"]], [7, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"ROAD\"]]],\n  'Three-way crossroad': [[1, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"ROAD\"]], [5, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"ROAD\"]], [6, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"ROAD\"]], [7, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"ROAD\"]]],\n  'Four-way crossroad': [[1, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"ROAD\"]], [5, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"ROAD\"]], [6, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"ROAD\"]], [7, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"ROAD\"]], [11, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"ROAD\"]]],\n  'Side city': [[0, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [1, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [2, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]]],\n  'Twin side city': [[0, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [1, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [2, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [10, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [11, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [12, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]]],\n  'City corner': [[0, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [1, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [2, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [3, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [5, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [8, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]]],\n  'City corner with road': [[0, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [1, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [2, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [3, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [5, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [8, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [11, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"ROAD\"]], [6, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"ROAD\"]], [7, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"ROAD\"]]],\n  'City entryway': [[1, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"ROAD\"]], [3, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [4, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [5, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [6, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [7, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [8, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [9, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [10, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [11, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [12, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]]],\n  'City fortification': [[3, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [4, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [5, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [6, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [7, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [8, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [9, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [10, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [11, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [12, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]]],\n  'Accordion city': [[3, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [4, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [5, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [6, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [7, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [8, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [9, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]]],\n  'Inner city': [[0, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [1, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [2, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [3, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [4, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [5, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [6, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [7, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [8, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [9, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [10, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [11, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [12, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]]],\n  Monastery: [[6, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"MONASTERY\"]]],\n  'Monastery with road': [[1, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"ROAD\"]], [6, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"MONASTERY\"]]]\n};\nconst START_TILE = generateTileTemplate([['name', 'Start tile'], [1, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"ROAD\"]], [6, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"ROAD\"]], [11, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"ROAD\"]], [4, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [7, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]], [9, _nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]]]);\nconst TILE_TYPES = [...generateTileTemplatesFromModifierMaps()];\nconst TILE_TYPE_NAMED_MAP = new Map(TILE_TYPES.map(tile => [tile.get('name'), tile]));\nconst TILE_TYPE_NUMBERED_MAP = new Map(TILE_TYPES.map((tile, index) => [index, tile]));\n\n//# sourceURL=webpack:///./src/engine/tileTypes.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _engine_gameLogic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./engine/gameLogic */ \"./src/engine/gameLogic.js\");\n/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./renderer */ \"./src/renderer/index.js\");\n/* harmony import */ var _index_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.scss */ \"./src/index.scss\");\n/* harmony import */ var _index_scss__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_index_scss__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nlet gameState = {\n  extensions: [],\n  seed: undefined,\n  world: new Map(),\n  nodeRelations: new Map(),\n  tileToPlace: new Map(),\n  stack: new Map(),\n  turn: 0,\n  phase: 'pick-tile',\n  players: [{\n    name: 'Bob',\n    color: 'red',\n    meeples: 7\n  }, {\n    name: 'John',\n    color: 'blue',\n    meeples: 7\n  }, {\n    name: 'Jane',\n    color: 'purple',\n    meeples: 7\n  }, {\n    name: 'Alberta',\n    color: 'yellow',\n    meeples: 7\n  }]\n};\n\nfunction initGame() {\n  const startTilePosition = '0/0';\n  const startTile = Object(_engine_gameLogic__WEBPACK_IMPORTED_MODULE_0__[\"pickStartTile\"])(gameState.extensions);\n  gameState.seed = Object(_engine_gameLogic__WEBPACK_IMPORTED_MODULE_0__[\"initRNG\"])(11875250475179788);\n  gameState.stack = Object(_engine_gameLogic__WEBPACK_IMPORTED_MODULE_0__[\"generateTiles\"])(82);\n  gameState.nodeRelations = Object(_engine_gameLogic__WEBPACK_IMPORTED_MODULE_0__[\"getInternalNodesWithTileId\"])(startTilePosition, startTile);\n  gameState.world.set(startTilePosition, startTile);\n  Object(_renderer__WEBPACK_IMPORTED_MODULE_1__[\"initRender\"])(gameState);\n}\n\ninitGame();\nObject(_renderer__WEBPACK_IMPORTED_MODULE_1__[\"render\"])(gameState);\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/index.scss":
/*!************************!*\
  !*** ./src/index.scss ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! ../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !../node_modules/css-loader/dist/cjs.js!../node_modules/sass-loader/dist/cjs.js!./index.scss */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/index.scss\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack:///./src/index.scss?");

/***/ }),

/***/ "./src/renderer/index.js":
/*!*******************************!*\
  !*** ./src/renderer/index.js ***!
  \*******************************/
/*! exports provided: initRender, render */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"initRender\", function() { return initRender; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony import */ var _engine_nodeTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../engine/nodeTypes */ \"./src/engine/nodeTypes.js\");\n/* harmony import */ var _engine_gameLogic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../engine/gameLogic */ \"./src/engine/gameLogic.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util */ \"./src/util.js\");\n\n\n\nconst TILE_SIZE = 60;\nconst NODE_SIZE = TILE_SIZE / 3;\nconst NODE_ID_MAP = new Map([[`0/0`, 0], [`20/0`, 1], [`40/0`, 2], [`??/??`, 3], [`??/??`, 4], [`0/20`, 5], [`20/20`, 6], [`40/20`, 7], [`??/??`, 8], [`??/??`, 9], [`0/40`, 10], [`20/40`, 11], [`40/40`, 12]]);\nconst LEFT_PADDING_OFFSET = 240;\nconst TOP_PADDING_OFFSET = 240;\n\nfunction getElement(id) {\n  const element = document.getElementById(id);\n\n  if (!element) {\n    throw new Error(`Element '#${id}' not found.`);\n  }\n\n  return element;\n}\n\nfunction createElement(type, id) {\n  const element = document.createElement(type);\n  element.id = id;\n  return element;\n}\n\nfunction getOffset(offsetMultiplier) {\n  const offsetBase = TILE_SIZE / 3;\n  return offsetBase * offsetMultiplier;\n}\n\nfunction drawNode(index, node, canvas) {\n  switch (node.feature) {\n    default:\n      {\n        return;\n      }\n\n    case _engine_nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"ROAD\"]:\n      {\n        canvas.fillStyle = 'rgb(200, 180, 90)';\n        break;\n      }\n\n    case _engine_nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"CITY\"]:\n      {\n        canvas.fillStyle = 'rgb(120, 80, 40)';\n        break;\n      }\n\n    case _engine_nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"MONASTERY\"]:\n      {\n        canvas.fillStyle = 'rgb(140, 160, 170)';\n        break;\n      }\n\n    case _engine_nodeTypes__WEBPACK_IMPORTED_MODULE_0__[\"RIVER\"]:\n      {\n        canvas.fillStyle = 'rgb(40, 60, 230)';\n        break;\n      }\n  }\n\n  switch (index) {\n    default:\n      {\n        // Don't draw\n        return;\n      }\n\n    case 0:\n      {\n        canvas.beginPath();\n        canvas.moveTo(getOffset(0), getOffset(0));\n        canvas.lineTo(getOffset(1), getOffset(1));\n        canvas.lineTo(getOffset(1), getOffset(0));\n        canvas.fill();\n        return;\n      }\n\n    case 1:\n      {\n        canvas.fillRect(getOffset(1), getOffset(0), getOffset(1), getOffset(1));\n        return;\n      }\n\n    case 2:\n      {\n        canvas.beginPath();\n        canvas.moveTo(getOffset(2), getOffset(0));\n        canvas.lineTo(getOffset(2), getOffset(1));\n        canvas.lineTo(getOffset(3), getOffset(0));\n        canvas.fill();\n        return;\n      }\n\n    case 3:\n      {\n        canvas.beginPath();\n        canvas.moveTo(getOffset(0), getOffset(0));\n        canvas.lineTo(getOffset(0), getOffset(1));\n        canvas.lineTo(getOffset(1), getOffset(1));\n        canvas.fill();\n        return;\n      }\n\n    case 4:\n      {\n        canvas.beginPath();\n        canvas.moveTo(getOffset(3), getOffset(0));\n        canvas.lineTo(getOffset(2), getOffset(1));\n        canvas.lineTo(getOffset(3), getOffset(1));\n        canvas.fill();\n        return;\n      }\n\n    case 5:\n      {\n        canvas.fillRect(getOffset(0), getOffset(1), getOffset(1), getOffset(1));\n        return;\n      }\n\n    case 6:\n      {\n        canvas.fillRect(getOffset(1), getOffset(1), getOffset(1), getOffset(1));\n        return;\n      }\n\n    case 7:\n      {\n        canvas.fillRect(getOffset(2), getOffset(1), getOffset(1), getOffset(1));\n        return;\n      }\n\n    case 8:\n      {\n        canvas.beginPath();\n        canvas.moveTo(getOffset(0), getOffset(2));\n        canvas.lineTo(getOffset(1), getOffset(2));\n        canvas.lineTo(getOffset(0), getOffset(3));\n        canvas.fill();\n        return;\n      }\n\n    case 9:\n      {\n        canvas.beginPath();\n        canvas.moveTo(getOffset(2), getOffset(2));\n        canvas.lineTo(getOffset(3), getOffset(2));\n        canvas.lineTo(getOffset(3), getOffset(3));\n        canvas.fill();\n        return;\n      }\n\n    case 10:\n      {\n        canvas.beginPath();\n        canvas.moveTo(getOffset(0), getOffset(3));\n        canvas.lineTo(getOffset(1), getOffset(3));\n        canvas.lineTo(getOffset(1), getOffset(2));\n        canvas.fill();\n        return;\n      }\n\n    case 11:\n      {\n        canvas.fillRect(getOffset(1), getOffset(2), getOffset(1), getOffset(1));\n        return;\n      }\n\n    case 12:\n      {\n        canvas.beginPath();\n        canvas.moveTo(getOffset(2), getOffset(2));\n        canvas.lineTo(getOffset(2), getOffset(3));\n        canvas.lineTo(getOffset(3), getOffset(3));\n        canvas.fill();\n        return;\n      }\n  }\n}\n\nfunction drawTile(tile, id) {\n  const element = createElement('canvas', id);\n  element.style.backgroundColor = 'green';\n  element.style.width = `${TILE_SIZE}px`;\n  element.style.height = `${TILE_SIZE}px`;\n  element.width = TILE_SIZE;\n  element.height = TILE_SIZE;\n  const canvas = element.getContext('2d');\n  tile.forEach((value, key) => {\n    if (Object(_util__WEBPACK_IMPORTED_MODULE_2__[\"isNumber\"])(key)) {\n      drawNode(key, value, canvas);\n    }\n  });\n  return element;\n}\n\nfunction drawWorldTiles(worldState, container) {\n  worldState.forEach((value, key) => {\n    if (Object(_util__WEBPACK_IMPORTED_MODULE_2__[\"isCoordinates\"])(key)) {\n      const [x, y] = key.split('/').map(fragment => Number(fragment));\n      const offsetX = x * TILE_SIZE;\n      const offsetY = y * TILE_SIZE;\n      const tile = drawTile(value, `world${key}`);\n      tile.style.position = 'absolute';\n      tile.style.marginLeft = `${offsetX}px`;\n      tile.style.marginTop = `${offsetY}px`;\n      container.append(tile);\n    }\n  });\n}\n\nfunction drawTileToPlace(tileToPlace, container) {\n  const tile = drawTile(tileToPlace, `tile-to-place0`);\n  container.append(tile);\n}\n\nfunction snapToGrid(coordinate) {\n  return Math.floor(coordinate / TILE_SIZE) * TILE_SIZE;\n}\n\nfunction snapToNode(coordinate) {\n  return Math.floor(coordinate / NODE_SIZE) * NODE_SIZE;\n} // TODO\n\n\nfunction canPlaceTileInWorld(tile) {\n  return true;\n}\n\nfunction initRender(gameState) {\n  const seed = getElement('seed');\n  seed.innerHTML = gameState.seed;\n  const stack = getElement('stack');\n\n  stack.onclick = () => {\n    let canPlaceTile = false;\n    let tile = undefined;\n    let updatedStack = undefined;\n\n    while (!canPlaceTile) {\n      ({\n        tile,\n        updatedStack\n      } = Object(_engine_gameLogic__WEBPACK_IMPORTED_MODULE_1__[\"removeTileFromStack\"])(gameState.stack));\n      canPlaceTile = canPlaceTileInWorld(tile);\n      gameState.stack = updatedStack;\n\n      if (updatedStack.size === 0) {\n        break;\n      }\n    }\n\n    if (!canPlaceTile) {\n      gameState.phase = 'endgame';\n      render(gameState);\n      return;\n    }\n\n    gameState.tileToPlace = tile;\n    gameState.phase = 'place-tile';\n    const tileToPlace = getElement('tile-to-place');\n    drawTileToPlace(gameState.tileToPlace, tileToPlace);\n    render(gameState);\n  };\n\n  const rotate = getElement('rotate');\n  rotate.style.display = 'none';\n\n  rotate.onclick = () => {\n    const updatedTileToPlace = Object(_engine_gameLogic__WEBPACK_IMPORTED_MODULE_1__[\"rotateTile\"])(gameState.tileToPlace);\n    gameState.tileToPlace = updatedTileToPlace;\n    const tileToPlace = getElement('tile-to-place');\n    tileToPlace.innerHTML = null;\n    drawTileToPlace(updatedTileToPlace, tileToPlace);\n  };\n\n  const endTurn = getElement('end-turn');\n\n  endTurn.onclick = () => {\n    gameState.phase = 'pick-tile';\n    gameState.turn++;\n    render(gameState);\n  };\n\n  document.onkeypress = ({\n    code\n  }) => {\n    switch (code) {\n      case 'Enter':\n        {\n          switch (gameState.phase) {\n            case 'pick-tile':\n              {\n                let canPlaceTile = false;\n                let tile = undefined;\n                let updatedStack = undefined;\n\n                while (!canPlaceTile) {\n                  ({\n                    tile,\n                    updatedStack\n                  } = Object(_engine_gameLogic__WEBPACK_IMPORTED_MODULE_1__[\"removeTileFromStack\"])(gameState.stack));\n                  canPlaceTile = canPlaceTileInWorld(tile);\n                  gameState.stack = updatedStack;\n\n                  if (updatedStack.size === 0) {\n                    break;\n                  }\n                }\n\n                if (!canPlaceTile) {\n                  gameState.phase = 'endgame';\n                  render(gameState);\n                  return;\n                }\n\n                gameState.tileToPlace = tile;\n                gameState.phase = 'place-tile';\n                const tileToPlace = getElement('tile-to-place');\n                drawTileToPlace(gameState.tileToPlace, tileToPlace);\n                render(gameState);\n                break;\n              }\n\n            case 'place-meeple':\n              {\n                gameState.phase = 'pick-tile';\n                gameState.turn++;\n                render(gameState);\n              }\n          }\n\n          break;\n        }\n\n      case 'KeyR':\n        {\n          if (gameState.phase === 'place-tile') {\n            const updatedTileToPlace = Object(_engine_gameLogic__WEBPACK_IMPORTED_MODULE_1__[\"rotateTile\"])(gameState.tileToPlace);\n            gameState.tileToPlace = updatedTileToPlace;\n            const tileToPlace = getElement('tile-to-place');\n            tileToPlace.innerHTML = null;\n            drawTileToPlace(updatedTileToPlace, tileToPlace);\n          }\n        }\n    }\n  };\n\n  const world = getElement('world');\n\n  world.onmousemove = ({\n    pageX,\n    pageY\n  }) => {\n    switch (gameState.phase) {\n      case 'place-tile':\n        {\n          const tileToPlace = getElement('tile-to-place');\n          const left = snapToGrid(pageX);\n          const top = snapToGrid(pageY);\n\n          if (left / TILE_SIZE < 0) {\n            return;\n          }\n\n          if (top / TILE_SIZE <= 0) {\n            return;\n          }\n\n          tileToPlace.style.left = `${left}px`;\n          tileToPlace.style.top = `${top}px`;\n          break;\n        }\n\n      case 'place-meeple':\n        {\n          const left = snapToGrid(pageX);\n          const top = snapToGrid(pageY);\n\n          if (left / TILE_SIZE < 0) {\n            return;\n          }\n\n          if (top / TILE_SIZE <= 0) {\n            return;\n          }\n\n          const hoveredElements = document.elementsFromPoint(left, top);\n          const hoveredTileElement = hoveredElements.find(element => Object(_util__WEBPACK_IMPORTED_MODULE_2__[\"isWorldElement\"])(element.id));\n\n          if (!hoveredTileElement) {\n            return;\n          }\n\n          const hoveredTileId = hoveredTileElement.id.replace('world', '');\n          const hoveredTile = gameState.world.get(hoveredTileId);\n          const nodeX = snapToNode(pageX - left);\n          const nodeY = snapToNode(pageY - top);\n          const nodeIndex = NODE_ID_MAP.get(`${nodeX}/${nodeY}`);\n          const hoveredNode = hoveredTile.get(nodeIndex); // TODO: Traverse node relations to get all the connected nodes\n\n          const hoveredNodeRelations = gameState.nodeRelations.get(`${hoveredTileId}/${nodeIndex}`);\n          console.log({\n            hoveredTile,\n            hoveredNode,\n            hoveredNodeRelations\n          });\n          break;\n        }\n    }\n  };\n\n  world.onclick = ({\n    pageX,\n    pageY\n  }) => {\n    if (gameState.phase === 'place-tile') {\n      const x = snapToGrid(pageX - LEFT_PADDING_OFFSET) / TILE_SIZE;\n      const y = snapToGrid(pageY - TOP_PADDING_OFFSET) / TILE_SIZE;\n      const westCoordinates = `${x - 1}/${y}`;\n      const westTile = gameState.world.get(westCoordinates);\n      const eastCoordinates = `${x + 1}/${y}`;\n      const eastTile = gameState.world.get(eastCoordinates);\n      const northCoordinates = `${x}/${y + 1}`;\n      const northTile = gameState.world.get(northCoordinates);\n      const southCoordinates = `${x}/${y - 1}`;\n      const southTile = gameState.world.get(southCoordinates);\n      const adjacentTiles = new Map();\n\n      if (westTile) {\n        adjacentTiles.set(`W`, westTile);\n      }\n\n      if (eastTile) {\n        adjacentTiles.set(`E`, eastTile);\n      }\n\n      if (northTile) {\n        adjacentTiles.set(`N`, northTile);\n      }\n\n      if (southTile) {\n        adjacentTiles.set(`S`, southTile);\n      }\n\n      if (adjacentTiles.size === 0) {\n        return;\n      }\n\n      const nodesA = [];\n      const nodesB = [];\n      let indexNodesA = [];\n      let indexNodesB = [];\n      let adjacentTilePosition = {\n        x: 0,\n        y: 0\n      };\n\n      for (let [direction, tile] of adjacentTiles) {\n        switch (direction) {\n          case 'W':\n            {\n              indexNodesA = [3, 5, 8];\n              indexNodesB = [4, 7, 9];\n              adjacentTilePosition = {\n                x: x - 1,\n                y\n              };\n              break;\n            }\n\n          case 'E':\n            {\n              indexNodesA = [4, 7, 9];\n              indexNodesB = [3, 5, 8];\n              adjacentTilePosition = {\n                x: x + 1,\n                y\n              };\n              break;\n            }\n\n          case 'N':\n            {\n              indexNodesA = [10, 11, 12];\n              indexNodesB = [0, 1, 2];\n              adjacentTilePosition = {\n                x,\n                y: y + 1\n              };\n              break;\n            }\n\n          case 'S':\n            {\n              indexNodesA = [0, 1, 2];\n              indexNodesB = [10, 11, 12];\n              adjacentTilePosition = {\n                x,\n                y: y - 1\n              };\n              break;\n            }\n        }\n\n        for (let i = 0; i < indexNodesA.length; i++) {\n          nodesA.push(gameState.tileToPlace.get(indexNodesA[i]));\n        }\n\n        for (let i = 0; i < indexNodesB.length; i++) {\n          nodesB.push(tile.get(indexNodesB[i]));\n        }\n\n        const canConnect = Object(_engine_gameLogic__WEBPACK_IMPORTED_MODULE_1__[\"canConnectNodes\"])(nodesA, nodesB);\n\n        if (!canConnect) {\n          return;\n        }\n\n        indexNodesA.forEach((nodeIndex, index) => {\n          const nodeRelationA = `${x}/${y}/${nodeIndex}`;\n          const nodeRelationB = `${adjacentTilePosition.x}/${adjacentTilePosition.y}/${indexNodesB[index]}`;\n          const existingNodeRelationA = gameState.nodeRelations.get(nodeRelationA) || [];\n          gameState.nodeRelations.set(nodeRelationA, [...existingNodeRelationA, nodeRelationB]);\n          const existingNodeRelationB = gameState.nodeRelations.get(nodeRelationB) || [];\n          gameState.nodeRelations.set(nodeRelationB, [...existingNodeRelationB, nodeRelationA]);\n        });\n      }\n\n      const tileToPlace = getElement('tile-to-place');\n      tileToPlace.innerHTML = null;\n      stack.style.pointerEvents = null;\n      const rotate = getElement('rotate');\n      rotate.style.display = 'none';\n      const internalNodeRelations = Object(_engine_gameLogic__WEBPACK_IMPORTED_MODULE_1__[\"getInternalNodesWithTileId\"])(`${x}/${y}`, gameState.tileToPlace);\n      const worldNodeRelations = gameState.nodeRelations;\n      gameState.nodeRelations = new Map([...worldNodeRelations, ...internalNodeRelations]);\n      gameState.world.set(`${x}/${y}`, gameState.tileToPlace);\n      gameState.tileToPlace = new Map();\n      gameState.phase = 'place-meeple';\n      render(gameState);\n    }\n  };\n}\nfunction render(gameState) {\n  const turnCount = getElement('turn-count');\n  turnCount.innerHTML = gameState.turn;\n  const currentPlayer = gameState.players[gameState.turn % gameState.players.length];\n  const turnPlayer = getElement('turn-player');\n  turnPlayer.innerHTML = currentPlayer.name;\n  turnPlayer.style.color = currentPlayer.color;\n  const phase = getElement('phase');\n  phase.innerHTML = gameState.phase;\n\n  switch (gameState.phase) {\n    case 'pick-tile':\n      {\n        const stack = getElement('stack');\n        stack.style.display = null;\n        const placeMeeples = getElement('place-meeple');\n        placeMeeples.style.display = 'none';\n        const endTurn = getElement('end-turn');\n        endTurn.style.display = 'none';\n        const tilesInStack = getElement('tiles-in-stack');\n        tilesInStack.innerHTML = gameState.stack.size;\n        break;\n      }\n\n    case 'place-tile':\n      {\n        const stack = getElement('stack');\n        stack.style.display = 'none';\n        const rotate = getElement('rotate');\n        rotate.style.display = null;\n        break;\n      }\n\n    case 'place-meeple':\n      {\n        const placeMeeples = getElement('place-meeple');\n        placeMeeples.style.display = null;\n        const endTurn = getElement('end-turn');\n        endTurn.style.display = null;\n        const meeplesLeft = getElement('meeples-left');\n        meeplesLeft.innerHTML = currentPlayer.meeples;\n        break;\n      }\n\n    case 'endgame':\n      {\n        const stack = getElement('stack');\n        stack.style.display = 'none';\n        break;\n      }\n  }\n\n  const world = getElement('world');\n  world.innerHTML = null;\n  drawWorldTiles(gameState.world, world);\n  window.gameState = gameState;\n}\n\n//# sourceURL=webpack:///./src/renderer/index.js?");

/***/ }),

/***/ "./src/util.js":
/*!*********************!*\
  !*** ./src/util.js ***!
  \*********************/
/*! exports provided: isNumber, isCoordinates, isWorldElement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNumber\", function() { return isNumber; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isCoordinates\", function() { return isCoordinates; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isWorldElement\", function() { return isWorldElement; });\nfunction isNumber(primitive) {\n  return String(primitive).match(/^\\d+$/);\n}\nfunction isCoordinates(primitive) {\n  return String(primitive).match(/^(-)?\\d+\\/(-)?\\d+$/);\n}\nfunction isWorldElement(primitive) {\n  return String(primitive).match(/^world(-)?\\d+\\/(-)?\\d+$/);\n}\n\n//# sourceURL=webpack:///./src/util.js?");

/***/ }),

/***/ 0:
/*!*******************************************************************!*\
  !*** multi (webpack)-dev-server/client?http://0.0.0.0:8080 ./src ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! /Users/owner/Projects/not-carcassonne/node_modules/webpack-dev-server/client/index.js?http://0.0.0.0:8080 */\"./node_modules/webpack-dev-server/client/index.js?http://0.0.0.0:8080\");\nmodule.exports = __webpack_require__(/*! ./src */\"./src/index.js\");\n\n\n//# sourceURL=webpack:///multi_(webpack)-dev-server/client?");

/***/ })

},[[0,"runtime","vendors~main"]]]);